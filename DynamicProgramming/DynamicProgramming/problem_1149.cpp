/*
  #. [ RGB거리 ]

  #. 문제
     RGB거리에는 집이 N개 있다. 거리는 선분으로 나타낼 수 있고, 1번 집부터 N번 집이 순서대로 있다.
     집은 빨강, 초록, 파랑 중 하나의 색으로 칠해야 한다.
     각각의 집을 빨강, 초록, 파랑으로 칠하는 비용이 주어졌을 때, 아래 규칙을 만족하면서 모든 집을 칠하는 비용의 최솟값을 구해보자.

     1번 집의 색은 2번 집의 색과 같지 않아야 한다.
     N번 집의 색은 N-1번 집의 색과 같지 않아야 한다.
     i(2 ≤ i ≤ N-1)번 집의 색은 i-1번, i+1번 집의 색과 같지 않아야 한다.

  #. 입력
     첫째 줄에 집의 수 N(2 ≤ N ≤ 1,000)이 주어진다.
     둘째 줄부터 N개의 줄에는 각 집을 빨강, 초록, 파랑으로 칠하는 비용이 1번 집부터 한 줄에 하나씩 주어진다.
     집을 칠하는 비용은 1,000보다 작거나 같은 자연수이다.

  #. 출력
     첫째 줄에 모든 집을 칠하는 비용의 최솟값을 출력한다.

  #. 예제 입력 1
     3
     26 40 83
     49 60 57
     13 89 99
     예제 출력 1
     96
*/

#include <iostream>
using namespace std;

int dp[1001][3];
int cost[1001][3];

int getMin(int num1, int num2)
{
    return num1 < num2 ? num1 : num2;
}


int solution(int n)
{
    //base case
    for (int i = 0; i < 3; i++)
        dp[0][i] = 0;

    //bottom-up
    /*
      현재 단계에서 무조건 최소값을 고르는 것이 결과값이 최소가 되는 것은 아님.
      즉 greedy한 접근으로 풀면 안된다.
      
      이전 단계에서 각 R, G, B값을 선택하였을 때, 이 선택한 값을 제외한 값중 최솟값 + 현재 값이 최소가 되어야.
      따라서 점화식이 3개가 나오고
      이 중 최솟값을 이 정답이다. 
    */
    for (int i = 1; i <= n; i++)
    {
        //이전 단계에서 R선택했을 경우
        dp[i][0] = getMin(dp[i-1][1], dp[i-1][2]) + cost[i][0];
        //이전 단계에서 G선택했을 경우
        dp[i][1] = getMin(dp[i-1][0], dp[i-1][2]) + cost[i][1];
        //이전 단계에서 B선택했을 경우
        dp[i][2] = getMin(dp[i-1][0], dp[i-1][1]) + cost[i][2];
    }

    return getMin(getMin(dp[n][0], dp[n][1]), dp[n][2]);
}


int main()
{
    int n;
    cin >> n;

    for (int i = 1; i <= n; i++)
    {
        for (int j = 0; j < 3; j++)
            cin >> cost[i][j];
    }

    cout << solution(n) << "\n";

    return 0;
}