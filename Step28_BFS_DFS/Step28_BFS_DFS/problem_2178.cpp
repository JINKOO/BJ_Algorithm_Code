/*
  #. [ 미로 탐색 ]
  
  #. 문제
     N×M크기의 배열로 표현되는 미로가 있다.

        1	0	1	1	1	1
        1	0	1	0	1	0
        1	0	1	0	1	1
        1	1	1	0	1	1
        
     미로에서 1은 이동할 수 있는 칸을 나타내고, 0은 이동할 수 없는 칸을 나타낸다. 
     이러한 미로가 주어졌을 때, (1, 1)에서 출발하여 (N, M)의 위치로 이동할 때 지나야 하는 최소의 칸 수를 구하는 프로그램을 작성하시오. 
     한 칸에서 다른 칸으로 이동할 때, 서로 인접한 칸으로만 이동할 수 있다.
    
     위의 예에서는 15칸을 지나야 (N, M)의 위치로 이동할 수 있다. 칸을 셀 때에는 시작 위치와 도착 위치도 포함한다.

  #. 입력
     첫째 줄에 두 정수 N, M(2 ≤ N, M ≤ 100)이 주어진다. 다음 N개의 줄에는 M개의 정수로 미로가 주어진다. 
     각각의 수들은 붙어서 입력으로 주어진다.

  #. 출력
     첫째 줄에 지나야 하는 최소의 칸 수를 출력한다. 항상 도착위치로 이동할 수 있는 경우만 입력으로 주어진다.

  #. 예제 입력 1 
     4 6
     101111
     101010
     101011
     111011
  #. 예제 출력 1 
     15

  #. 예제 입력 2 
     4 6
     110110
     110110
     111111
     111101
  #. 예제 출력 2 
     9
  
  #. 예제 입력 3 
     2 25
     1011101110111011101110111
     1110111011101110111011101
  #. 예제 출력 3 
     38

  #. 예제 입력 4 
     7 7
     1011111
     1110001
     1000001
     1000001
     1000001
     1000001
     1111111

  #. 예제 출력 4 
     13
*/

#include <iostream>
#include <queue>
using namespace std;

string map[100];
int record[100][100];
int check[100][100];

int di[4] = { -1, 0, 1, 0 };
int dj[4] = { 0, 1, 0, -1 };

/*
  접근법
  - 미로에서 최단 거리를 찾아야 하므로 bfs를 사용한다.
  - 이 문제에서 dfs를 사용해도 되지만, 4가지 경우(상하좌우)등의 모든 경우의 수를 탐색한 후 최솟값 찾아야
    --> 백준에서 시간초과 나온다.
  
  중요한 점
  - record라는 이차원 배열을 사용하여 현재 위치까지 올 수 있는 경우의 수 기록한다. 
    bfs에서 큐를 사용하므로 최단 거리 가능하다.

*/
void bfs(int i, int j, int n, int m)
{
    queue<pair<int, int>> q;

    q.push(make_pair(i, j));
    check[i][j] = true;

    while (!q.empty())
    {
        pair<int, int> p = q.front();
        q.pop();

        for (int k = 0; k < 4; k++)
        {
            int next_i = p.first + di[k];
            int next_j = p.second + dj[k];

            //현재 위치에서 상하죄우 위치가 map[][]범위 안에 존재하고,
            if (next_i >= 0 && next_i < n && next_j >= 0 && next_j < m)
            {
                //그 위치가 길이고(1인위치), 아직 방문하지 않았으며, 최단 경로 수가 기록되지 않은 곳이면,
                if (map[next_i][next_j] == '1' && check[next_i][next_j] == false && record[next_i][next_j] == 0)
                {
                    //큐에 삽입
                    q.push(make_pair(next_i, next_j));
                    //방문 처리
                    check[next_i][next_j] = true;
                    //현재까지 온 수 + 1 --> 현재 위치에서 상하좌우 중 1인 경로로 가는 경우는 1이다.
                    //이 부분이 최단 경로를 구할 수 있는 원리다.
                    record[next_i][next_j] = record[p.first][p.second] + 1;
                }
            }
        }
    }
}

int main()
{
    int n, m;
    cin >> n >> m;

    for (int i = 0; i < n; i++)
        cin >> map[i];
    
    bfs(0, 0, n, m);

    //record출력 해보기.
    /*for (int i = 0; i < n; i++)
    {
        for (int j = 0; j < m; j++)
            cout << record[i][j] << " ";
        cout << "\n";
    }*/
    cout << record[n - 1][m - 1] + 1 << "\n";

    return 0;
}